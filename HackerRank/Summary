<To further study>
Java Iterator [?]
Java BigDecimal [QTA]

<Introduction>
>> Welcome to Java!
System.out.println("")

>> Java Stdin and Stdout I 
Scanner sc = new Scanner (System.in);
Type varName = sc.nextType();
sc.close();

>> If-Else
if(){}
else if(){}
else{}

- Ternary operator
ansType varName = (condition? true:false);

>> End Of File (EOF)
 while(scanner.hasNext()){
            text = scanner.nextLine();
            counter ++;
            System.out.println(counter + " " + text);}
	
>> Java Datatypes
Java has 8 primitive data types; char, boolean, byte, short, int, long, float, and double. 
For this exercise, we'll work with the primitives used to hold integer values (byte, short, int, and long):

A byte is an 8-bit signed integer.
A short is a 16-bit signed integer.
An int is a 32-bit signed integer.
A long is a 64-bit signed integer.
Given an input integer, you must determine which primitive data types are capable of properly storing that input.

 for(int i=0;i<t;i++)
        {
            try
            {
                long x=sc.nextLong();
                System.out.println(x+" can be fitted in:");
                if(x>=-128 && x<=127)System.out.println("* byte");
                if(x>=-32768 && x<=32767)System.out.println("* short");
                if(x>=Math.pow(-2,31) && x<=Math.pow(2,31)-1) System.out.println("* int");
                if(x>=Math.pow(-2,63) && x<=Math.pow(2,63)-1) System.out.println("* long");
            }
            catch(Exception e)
            {
                System.out.println(sc.next()+" can't be fitted anywhere.");
            }


<STRINGS>
>> Java Strings Introduction
- To initialize
String str = " "

- To length
str.length()

- To compare lexicographically
str1.compareTo(str2)
str1.compareToIgnoreCase(str2)
[str1 > str2 : +ve] [str1 = str2 : 0] [str1 < str2 : -ve]

- To capitalize the 1st letter
str1.substring(0,1).toUpperCase() + str1.substring(1, str1.length())

>>Java Substring
str.substring (beginIndexInclusive, endIndexExclusive)

>>Java Substring Comparisons 
- Get smallest & largest substrings (length k, string s)
 String smallest = "z"; #
 String largest = "";
 for(int i =0; i<=s.length()-k; i++){ #
            String line = (s.substring(i,i+k)); #
            if(line.compareTo(smallest)<0){
                smallest = line;
            }
            if(line.compareTo(largest)>0){
                largest = line;
            }
            
        }

>> Java String Reverse
- Palindrome: (word/phrase/number/sequence of characters) reads the same backward or forward
 boolean isEqual = true;       
        for(int i = 0; i<=A.length()-1; i++){
            if(A.charAt(i) != A.charAt(A.length()-1-i)){
                isEqual = false;
            }
        }

>> Java Anagrams 
2 strs contain all same chars in same frequencies
[1] str.toLowerCase(); //if case-insensitive
[2] str1.length() != str2.length() //>>false
[3] (A is str1, B is str2)
        for(int i=0;i<A.length();i++){
            int countA=0;
            int countB=0;
            
            for(int j=0;j<A.length();j++){
                if (A.charAt(i)==A.charAt(j)) countA++; #
        
                if (A.charAt(i)==B.charAt(j)) countB++; #
            
            } 
            if(countA==countB)  continue; #
            else  return false;
            }


>> Java String Tokens
- To split words by words & store in array
         String[] tokens = S.split("[^a-zA-Z]");

>> Java Regex
 - IP Address
 <Main>
 Scanner in = new Scanner(System.in);
        while(in.hasNext()){ 
            String IP = in.next();
            System.out.println(IP.matches(new MyRegex().pattern)); }#
	    
class MyRegex{
     String Limit_0_255 = "(\\d{1,2}|(0|1)\\d{2}|2[0-4]\\d|25[0-5])";
/*
/d is used for digits in regular expressions
(0|1)\\d{2} checks for a three digit number between 0 and 1
\\d{1,2} check for a one or two digit number
2[0-4]\\d|25[0-5] checks for numbers between 200 and 255
\\. represents a dot
*/
     
    //IP address has 4 parts
    public String pattern = Limit_0_255 + "\\." + Limit_0_255
            + "\\." + Limit_0_255
            + "\\." + Limit_0_255;
}

>> Java Regex 2
-  remove instances of words that are repeated more than once, but retain the first occurrence of any case-insensitive repeated word. 
RegEx match repeated word --> 2nd compile arg--> 2 necessary arg for replaceAll

 String regex = "\\b(\\w+)(?:\\W+\\1\\b)+" ;
 Pattern p = Pattern.compile(regex, Pattern.CASE_INSENSITIVE); #

        Scanner in = new Scanner(System.in);
        int numSentences = Integer.parseInt(in.nextLine());
        
        while (numSentences-- > 0) { #
            String input = in.nextLine();
            
            Matcher m = p.matcher(input);#
            
            // Check for subsequences of input that match the compiled pattern
            while (m.find()) { #
                input = input.replaceAll(m.group()/* The regex to replace */,m.group(1) /* The replacement. */); #
            }
            
            // Prints the modified sentence.
            System.out.println(input);
        }
        in.close();
    }
}


<DATA STRUCTURES>

>> Java 1D Array
while(scan.hasNextInt()){ 
      a[count++] = scan.nextInt(); //Increase count by 1 after assign
}

- To initialize:
int[] arrName = new int[4]; //store 4 integers, index from 0 to (size - 1)
- To store:
arrName[3] = 12;

>> Java Subarray
- input [1st line: array length] [2nd line: n spaces-separated integers]
        Scanner scanner = new Scanner(System.in);
        int[] numbers = new int[scanner.nextInt()];
        for (int i = 0; i < numbers.length; i++) {
            numbers[i] = scanner.nextInt();
        }
  
- FIND NO. OF NEGATIVE SUBARRAY
 // To access each subarray (from n = 1 to n = array.length)
        int k = 0;
        int count = 0;

        while (k < numbers.length) {
            for (int i = 0; i < numbers.length - k; i++) {
                int sum = 0;
                for (int j = i; j < i + 1 + k; j++) {
//To sum each subarray
         sum += numbers[j];
                }
//If is -ve subarray, count+1
         if (sum < 0)
             count++;
//Continue to access next subarray, increase n
            }
            k++;
        }

>> Java 2D Array
- Multidimensional Array
// Initialize
  int multiDimArr[][] = new int[6][6];
    
// Prompt input for value
		for(int row = 0; row < 6; row++){
			for(int col = 0; col < 6;col++){
				multiDimArr[row][col] = sc.nextInt();
			}
		}

// To loop through all element
// as 6x6, for hourglass must have 3 rows 3 columns, so at inclusive maximum 4th row & 4th column
for(int row = 0; row < 4; row++){
			for(int col = 0; col < 4; col++ ){
   
// To perform HOURGLASS sum (initialize total = 0)

| m11 m12 m13 |
| m21 m22 m23 |
| m31 m32 m33 |

[1] m11 + m12 + m13
				total = arr[row][col] + arr[row][col+1] + arr[row][col+2]; 
[2] + m22
				total += arr[row+1][col+1];
[3] + m31 + m32 + m33
				total += arr[row+2][col] + arr[row+2][col+1] + arr[row+2][col+2];
~ element included in calc will change as no. of row&col increase

// To find largest sum of hourglass
int max = Integer.MIN_VALUE;
max = total>max?total:max;
return max;

>> ArrayList
- Tell the number located in yth position of xth line
//Create ArrayList for list
        List<Integer>[] list = new ArrayList[n];
	 for(int i=0; i<n; i++){
            int sizeOfTheLine = scanner.nextInt();
            
 //Create ArrayList for line
            List<Integer> line = new ArrayList<>();
 //1st element of line is the size
            line.add(sizeOfTheLine);
 // Prompt input to fulfill no. of element in each line
            for(int j=0; j<sizeOfTheLine; j++){
                line.add(scanner.nextInt());
            }
//Save the line into list
            list[i] = line;
        }
        
//Prompt input for queries (no. of ques)
        int queries = scanner.nextInt();
//Prompt input for location (no. of times = no. of queries)
        for(int i=0; i<queries; i++){
            int x = scanner.nextInt();
            int y = scanner.nextInt();
	    
	    try{
//index in list = (xth - 1)line
//yth element = index is y as the 1st element abt length is included
                System.out.println(list[x-1].get(y)); #
            }catch(Exception e ){
                System.out.println("ERROR!");
            }
            
        }
        scanner.close();
	
>> Java Stack

Stack<String> stack = new Stack<String>();
stack.isEmpty(): Check if is empty
stack.empty() : If is empty condition
stack.pop()   : Remove last/top element
stack.push(item) : Add item to last/top
stack.lastElement().equals(""): Check if last element equals to ""

>> Java Sort
Name ID CGPA (Arrange CGPA, if same then arrange ID)
for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (data[i][2].compareTo(data[j][2]) < 0) { //#3rd element indexNo =2: ID Name CGPA
                    temp = data[j];
                    data[j] = data[i];
                    data[i] = temp;
                } else if (data[i][2].compareTo(data[j][2]) == 0) {
                    if (data[i][1].compareTo(data[j][1]) > 0) { //#
                        temp = data[j];
                        data[j] = data[i];
                        data[i] = temp;
                    }
                }
            }
        }

>> Java Currency Formatter
main{
Solution sol = new Solution();
        System.out.println("US: " + sol.formattedPayment(Locale.US, payment)); // Locale just capitalize its name
        System.out.println("India: "+ sol.formattedPayment(new Locale("en", "IN"), payment)); //Special case
        }

public String formattedPayment(Locale locale, double payment) {
     NumberFormat nf = NumberFormat.getCurrencyInstance(locale);
     return nf.format(payment);
}


<OBJECT ORIENTED PROGRAMMING>
>> Java Inheritance I
class A{ method p}
class B extend A{ method q}
- B.p() & B.q() //B can excess all in A

>> Java Inheritance II
- class A inherits from a superclass named Arithmetic
class A extends Arithmetic{}

- To get name of superClass
objName.getClass().getSuperclass().getName()

>> Java Abstract Class
//abstract class X instantiated (X create new instances/ Object)
// create another class that extends abstract class --> create instance of the new class
abstract class Book{}
class MyBook extends Book {}
main{ MyBook objName = new MyBook() }

//method abstract & has no body --> implement body of that method in child class
abstract: abstract void setTitle(String s);
child:  void setTitle(String s){title = s;}

>> Java Interface
- can only contain method signatures and fields
- can be used to achieve polymorphism. 
- 
interface A{ int divisor_sum(int n);}
class B implements A{  public int divisor_sum(int n){...return;}}
- To get the name of interface
Class[] theInterfaces = o.getClass().getInterfaces();
String interfaceName = theInterfaces[i].getName();

>> Java Method Overriding 
class A { Type method1(){p} }
class B extends A { @Override Type method1(){q}}
- B inherits A methods

<Main>
A objName = new A; 
A.method() >> p
B objName = new B;
B.method() >> q

>> Java Method Overriding 2 (Super Keyword)
//super.func() to call the overriden function in superclass
class B extends A{ Type function1(){q}
String temp = super.function1()
} 
Output: p

>>Java Instanceof keyword
//Add into arraylist distinguish by each class according to value
if(s.equals("Value")){
	arrayListName.add(new difClass());}
	
//To get a class name of object O
O.getClass().getName()

// To calc no. of element in each class
for(int i = 0; i < mylist.size(); i++){
         Object element=mylist.get(i);
         if(element.getClass().getName() == "Student") 
            a++;
	    //follow by b & c
	    
// To call count method in main
count(arrayListName);

<BIGNUMBER>
>> BigInteger
- Type: BigInteger
- Arithmetic: a.add(b), a.multiply(b)

>> Java Primality Test
BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));
String n = bufferedReader.readLine();
BigInteger bigInteger = new BigInteger(n + "");
if(bigInteger.isProbablePrime(1)) #

<EXCEPTION HANDLING>
try{ //what to do }
catch(Exception){}//Can be >=1
finally{sc.close();}

OR

class C {
  accessModifier Type Method(Parameters) throws Exception{
  if()
    throw(new Exception("");
  else if()
    throw(new Exception("");
  else()
    return
}

- Print
 catch(Exception e){System.out.println(e);}
 
 - Other type
 i. catch(InputMismatchException e) {System.out.print("java.util.InputMismatchException");}
