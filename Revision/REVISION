

@Swapping 2 vars
temp = a;
a = b;
b = temp; 

@sumDigits
int sum = 0;
while (n != 0) {
            sum += n % 10;
            n /= 10;
        }

@ divide using subtraction operator
int count = 0;
        while (dividend > divider){
            dividend-=divider;
            count++;
        }

@ reverseString
char[] letters = str.toCharArray();
for (int i = letters.length - 1; i >= 0; i--) {}	//print from last ele to first ele

@ rotate string by offset (rotate from left to right)
-e.g. offset3 [a,b,c,d,e] -> [c,d,e,a,b]
<Main>
char[] A = str.toCharArray();
reverse(A, 0, len - offset - 1);
reverse(A, len - offset, len - 1);
reverse(A, 0, len - 1);

private static void reverse(char[] str, int start, int end) {
        while (start < end) {
            char temp = str[start];
            str[start] = str[end];
            str[end] = temp;
            start++;
            end--;
        }
    }

*@ check PALINDROME
public static int reverse_nums(int n) {
        int reverse = 0;
        while (n != 0) {
            reverse *= 10;
            reverse += n % 10;
            n /= 10;
        }
        return reverse;
    }
public static boolean is_Palindrome(int n) {
        return (n == reverse_nums(n));
    }

@ multiple of 3 "Fizz", multiple of 5 "Buzz", multiple of 3&5 "Fizz Buzz"
if (both cond), else if(each cond)

*@ square root
private static int sqrt(int num) {
        if (num == 0 || num == 1) {
			return num;
		}
		int a = 0;
		int b = num;
		while (a <= b) {
			int mid = (a + b) >> 1;
			if (num / mid < mid) {
				b = mid - 1;
			} else {
				if (num / (mid + 1) <= mid) {
					return mid;
				}
				a = mid + 1;
			}
		}
		return a;
	}



@ count Letters, Spaces, Numbers, other Char
char[] ch = str.toCharArray();
Character.isLetter(ch[i]); //Repeat for .isDigit(), .isSpaceChar(); other Char use else{}
			
@ check even or odd
- even: n%2 == 0
- odd: n%2 != 0

@ divisible by i
n%i == 0

@ convert STRING to INT
Integer.parseInt(str)

@convert seconds to hour,minute&seconds
- SS : sec%60
- MM : sec%60/60
- HH : sec/60/60
	int S = seconds % 60;
        int H = seconds / 60;
        int M = H % 60;
        H = H / 60;

@ factors
	int ctr = 0;
        for(int i=1; i<=(int)Math.sqrt(num); i++) {
            if(num%i==0 && i*i!=num) {
                ctr+=2;
            } else if (i*i==num) {
                ctr++;
            }
        }

@ read int, calc sumOfDigits, write num of each digit of sum in English
<Main> //can use back sumDigits
char[] numStr = str.toCharArray();
for (int i = 0; i < numStr.length; i ++) {
	sum += numStr[i] - '0';			//[?QTA : why must '0' ---EX87]
}
<printNumber.java>
String[] number = {"zero","one","two","three","four","five","six","seven","eight","nine"};
//n is sumOfDigit
if (n < 10) {	//1 digit
	System.out.println(number[n]);
}
else if (n < 100) {	//2 digits
	x = n / 10;		//x=24/10 = 2
	y = n - x *10;		//y=24-2*10 = 4
	System.out.println("In English: "+number[x] + " " + number[y]);
}
else {			//3 digits
	x = n / 100;			
	y = (n - x * 100) / 10;
	z = n - x * 100 - y * 10;
	System.out.println("In English: "+number[x] + " " + number[y] + " " + number[z]);
}

*@ add all digits until result single
-%9 get single digit
if (n>0)
		{
           System.out.print("The single digit number is: "+(n == 0 ? 0 : (n % 9 == 0 ? 9 : n % 9)));
		}

@ check power of 4
- (n<1) : false
- (n&(n-1)!=0): false
- ((n & 0x55555555)!=0) : true

//If the number is 0 then clearly it is not power of 4.
        if (n < 1) {
            System.out.print(Boolean.toString(false));
            test = 1;
        }

        //If a number is power of 4 then it certainly is power of 2.
        //(n & (n-1)) == 0 only checks if n is a power of 2 or 0
        if ((n & (n - 1)) != 0) {                           //if(not power of 2)->false
            System.out.print(Boolean.toString(false));
            test = 1;
        }
        if (test==0)
        {
            //This statement checks if the bit is set at bit position 0,2,4,6,8 etc.Because then only it is a power of 4.
            System.out.print(Boolean.toString((n & 0x55555555) != 0));
OR
 static void power_of_four(int N) {
        float x = (float) (Math.log(N) / Math.log(4));    // Logb(N) = Log10(N)/log10(b).
        int y = (int) (Math.log(N) / Math.log(4));
        if ((N != 0) && (x ==y)){
            System.out.println("true");
        }else{
            System.out.println("false");        }
    }

*@ ADD without using arithmetic operators [?QTA]
while(y != 0){
            int carry = x & y;
            x = x ^ y;
            y = carry << 1;
        }
	
*@ compute num of trailing zeros in a factorial
- /5 until >0
while (n != 0) 
		{
			ctr += n / 5;
			n /= 5;
		}

@ Find distinct ways climb to the top (n steps to reach to the top) of stairs (either climb 1 or 2 steps)	[?QTA 134]
-e.g.: n = 5 a) 1+1+1+1+1 = 5 b) 1+1+1+2 = 5 c) 1+2+2 = 5 d) 2+2+1 = 5 e) 2+1+1+1 = 5 f) 2+1+2 = 5 g) 1+2+1+1 = 5 h) 1+1+2+1 = 5
https://www.w3resource.com/java-exercises/basic/java-basic-exercise-134.php

class Solution {
    public static int climbStairs(int n) {
        if (n <= 1) {
            return 1;
        }
        int[] s_case = new int[n + 1];
        s_case[0] = 1;
        s_case[1] = 1;
        for (int i = 2; i <= n; i++) {
            s_case[i] = s_case[i - 1] + s_case[i - 2];
        }      
        return s_case[n];
    }
    /* Driver program to test above functions */
    public static void main(String[] args) {
		int steps = 5;		                        
		System.out.println("Distinct ways can you climb to the top: "+climbStairs(steps));
	}	
}

@ find no. of bits required to flip to convert 2 given integers
- e.g. 27(11011) 23(10111) 2bits

public static int bitSwapRequired(int x, int y) {
        int ctr = 0;
        for (int z = x ^ y; z != 0; z = z >>> 1) {
            ctr += z & 1;
        }
        return ctr;
    }

@ 4 nums equality
if (num1 == num2 && num2 == num3 && num3 == num4) 

@ multiply without *
int multiply = 0;
    for (int i = 0; i<n1; i++){
        multiply += n2;
    }
-------------------------------------
public static int multiply(int n1, int n2) {
    int result = 0;
    boolean negative_num = (n1 < 0 && n2 >= 0) || (n2 < 0 && n1 >= 0);
    boolean positive_num = !negative_num;
    n1 = Math.abs(n1);
    for (int i = 0; i < n1; i++) {
      if (negative_num && n2 > 0 || positive_num && n2 < 0)
        result -= n2;
      else
        result += n2;
    }

    return result;
 }

<3 or n int>
@ sum of 2 int equal to 3rd
((p + q) == r || (q + r) == p || (r + p) == q)

@ 2nd > 1st; 3rd > 2nd; abc true, 2nd nonid >1st
if(abc)
	return (r > q);
return (q > p && r > q);

@ >=2 have same rightmost digit (all int +)
(p % 10 == q % 10) || (p % 10 == r % 10) || (q % 10 == r % 10)

@ no. of integers within range x to y, divisible by z
for(int i = x; i<=y; i++){
            if(i%p==0){count++;}
        }
OR
if (x%p == 0)
	return( y/p - x/p + 1);
return(y/p - x/p);

@ one of them is 20 or more and less than the substractions of others. (total 3 int)
(Math.abs(x - y) >= 20 || Math.abs(y - z) >= 20 || Math.abs(z - x) >= 20)

@ 2 int; return larger; if 2 same, return 0 & if /6 same remainder, return smaller value;
	if(x == y)
		return 0;
	    if(x % 6 == y % 6)
		    return (x < y) ? x : y;
	return (x > y) ? x : y;

@ 2 int between 25 to 75; common digit true
	if (p<25 || q>75)			//check in range
		   return false;
	   int x = p % 10;			//check leftmost digit
	   int y = q % 10;
	   p /= 10;				//check rightmost digit
	   q /= 10;
	   return (p == q || p == y || x == q || x == y);

@ 2 int, calc modulus of 2 num without using %
int divided = a / b;
int result = a - (divided * b);

@ compute sum of PRIME NUMBERS till 100
// prime
public static boolean is_Prime(int n) {
		for (int i = 3; i * i <= n; i+= 2) {
			if (n % i == 0) {
				return false; 
			}
		}
		return true;
	}
	
//sum of 100 prime num
while (ctr < 100) {
			n++; 
			if (n % 2 != 0) { 
			// check if the number is even
				if (is_Prime(n)) {
					sum += n; 					
				}
			}
                    ctr++; 	
		}
		
@ Prove Euclid's algorithm computes greatest common divisor (GCD)
		public static int euclid(int x, int y) {
		if (x == 0 || y == 0) {
			return 1;
		}
		if (x < y) {
			int t = x;
			x = y;
			y = t;
		}
		if (x % y == 0) {
			return y;
		} else {
			return euclid(y, x % y);
		}
	}
OR
public static int euclid(int x, int y){
   while (y != 0){
       int temp = x;
       x = y;
       y = temp % y;
   }
   return Math.abs(x);
   }

<SHAPE>
*@ Form a staircase shape of n coins where every k-th row must have exactly k coins
/* e.g.
n = 3
$
$ $
output: 2 (2 rows)
n = 5
$
$ $
$ $
output: 2 (2 rows as 3rd row incomplete)
*/
if (n>0){
    System.out.println("Number of rows: "+((int)((Math.sqrt(8 * (long)n + 1) - 1) / 2)));	}       

<PRINTF>
%d : int
%n : (platform indipendent) special code (placeholder) for new-line symbol (that might be \r\n or \n) in formatted string and \n is an actual symbol.
\n : new line
\t : 4 spaces

<System.out.format>
%tc: (dateTimeFormat) weekday month DD HH:MM:SS PDT year //%Tc: weekday & month in upper case

<Characters>
@ unique 3-digit numbers
- for(x=1; x<=4; x++); if(x!=y!=z); increase amount, print x y z
for(int i = 1; i <= 4; i++){
			for(int j = 1; j <= 4; j++){
				for(int k = 1; k <= 4; k++){
					if(k != i && k != j && i != j){
						amount++;
						System.out.println(i + "" + j + "" + k);
						}}}}

@ list available character sets in charset objects
-#Charset.availableCharsets().keySet()	//Take this as array
for (String str : Charset.availableCharsets().keySet()) {
      System.out.println(str);
    }
    
@ ASCII value of char
int chr = 'Z'; //print chr

<String>
@ Capitalize first letter
Scanner in = new Scanner(System.in);		//create Scanner
String line = in.nextLine();			//get input
String upper_case_line = ""; 			//Initialize str var
Scanner lineScan = new Scanner(line); 		//#Create scanner object
while(lineScan.hasNext()) {
             String word = lineScan.next(); 
             upper_case_line += Character.toUpperCase(word.charAt(0)) + word.substring(1) + " "; 
         }

@ convert str to lowercase
- #str.toLowerCase();
String line = in.nextLine();
	 line = line.toLowerCase();

@ find penultimate(next to last) word of a sentence
-# str.split("regex"); https://www.geeksforgeeks.org/split-string-java-examples/
String[] words = line.split("[ ]+"); //regex can be "[ ]+" or just " " for empty spaces
System.out.println("Penultimate word: "+words[words.length - 2]);
	 
@ reverse word
String word = in.nextLine();
word = word.trim();			//Remove leading & trailing white-space chars from string
String result = ""; 
char[] ch=word.toCharArray();  
for (int i = ch.length - 1; i >= 0; i--) {	//print from end to start of arr
	result += ch[i];
} //print(result.trim());

@ Insert word in middle of str
- Tutorial in Python 3.0
main_string.substring(0, 7) + word + main_string.substring(6)

@ 4 copies of last 3 char
String last3 = str.substring(str.length()-3);
System.out.println(last3 + last3 + last3 + last3);

@ extract first half of string of even length
str.substring(0, str.length()/2)

@ print shortString + longString + shortString
	if(str1.length() >= str2.length())
		System.out.println( str2+str1+str2);
	else
	System.out.println(str1+str2+str1);	
	
@ concatenation of 2 strs (remove first char of each)
str1.substring(1) + str2.substring(1)

@ take first 3 char, if str length < 3 use # substitute
	String str1 = "rr";
        int len = str1.length();
        if(len >= 3)
            System.out.println( str1.substring(0, 3));
        else if(len == 1)
            System.out.println( (str1.charAt(0)+"##"));
        else if(len == 2)
            System.out.println( (str1 +"#"));
        else
            System.out.println("###");
		
@ take first char str1 & last char str2, if str len 0 use #
	String result = "";
	result += (str1.length() >= 1) ? str1.charAt(0) : '#';
	result += (str.length() >= 1) ? str2.charAt(str2.length()-1) : '#';
	
@ take last 3 char, put at front & back
//if strLength < 3, return str
    String subpart = string1.substring(string1.length()-3);
    System.out.println(subpart + string1 + subpart);

*@ str start with specified word
System.out.println(str.startsWith("specifiedWord"));

*@ get first occ (Start from 0 index) of a string within a given string
public static int strStr(String source, String target) {
        if (source == null || target == null) {
            return -1;
        }
        if ("".equals(target) || source.equals(target)) {
            return 0;
        }
        int i = 0;
        int last = source.length() - target.length() + 1;
        while (i < last) {
            if (source.charAt(i) == target.charAt(0)) {	// if match first char, only continue check following char, else move to next char 
                boolean equal = true;
                for (int j = 0; j < target.length() && equal; ++j) {
                    if (source.charAt(i + j) != target.charAt(j)) { //#
                        equal = false;
                    }
                }
                if (equal) {
                    return i;
                }
            }
            ++i;
        }
        return -1;
    }

@ anagram: abc = cba
public static boolean anagram_test(String str1, String str2) {
        if (str1 == null || str2 == null) {
            return false;
        } else if (str1.length() != str2.length()) {
            return false;
        } else if (str1.length() == 0 && str2.length() == 0) {
            return false;}
        else{
            int index = str2.length() - 1;
            for (int i = 0; i < str1.length(); i++) {
                if (str1.charAt(i) != str2.charAt(index)) {
                    return false;
                }
                index--;
            }
        }
        return true;
    }
OR
public static boolean anagram_test(String str1, String str2) {
        if (str1 == null || str2 == null) {
            return false;
        } else if (str1.length() != str2.length()) {
            return false;
        } else if (str1.length() == 0 && str2.length() == 0) {
            return true;
        }
        int[] count = new int[256];
        for (int i = 0; i < str1.length(); i++) {
            count[str1.charAt(i)]++;
            count[str2.charAt(i)]--;
        }
        for (int num : count) {
            if (num != 0) {
                return false;
            }
        }
        return true;
    }

@ Find index of first unique character in string	//[?QTA 148]
public static int first_Uniq_Char(String s) {
         int[] freq = new int[256];
        for (char c : s.toCharArray()) {
            freq[c - 'a']++;
        }
        for (int i = 0; i < s.length(); i++) {
            if (freq[s.charAt(i) - 'a'] == 1) return i;
        }
        return -1;
	}

@ Check if this string is permutation of another string		//[?QTA 149]
 public static boolean stringPermutation(String str1, String str2) {
        int[] arr = new int[500];
        for (int i = 0; i < str1.length(); i++) {
            arr[(int) str1.charAt(i)] += 1;
        }
        for (int i = 0; i < str2.length(); i++) {
            arr[(int) str2.charAt(i)] -= 1;
        }
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] != 0) return false;
        }
        return true;
    }

@ transform int to String
Integer.toString(int)
[complicated 166] https://www.w3resource.com/java-exercises/basic/java-basic-exercise-166.php

@ reverse content of a string (without reverse words)
String[] words = str.split("\\s+");                    //# Split sentence into array by " "
        for (int i = 0; i < words.length; i++) {
            // You may want to check for a non-word character before blindly
            // performing a replacement
            // It may also be necessary to adjust the character class
            words[i] = words[i].replaceAll("[^\\w]", "");
        }
        String[] reversed = new String [words.length];
        for(int j = 0; j< words.length; j++){
            reversed[j] = words[words.length-1-j];
            System.out.print(reversed[j] + " ");
        }
------------------------------------------------------------------
public static String reverse_str_word(String input_sentence) {
    if (input_sentence == null) {
      throw new IllegalArgumentException("Input param can't be null.");
    }
    StringBuilder stringBuilder = new StringBuilder();
    String[] words = input_sentence.split(" ");
    for (int i = words.length - 1; i >= 0; i--) {
      stringBuilder.append(words[i]);
      if (i != 0) {
        stringBuilder.append(" ");
      }
    }
    return stringBuilder.toString();
  }
	
<Array>
@ Test x appears either first or last ele
(num_array[0] == 10 || num_array[num_array.length-1] == 10)

@ Test first & last ele same; Length>=2
(num_array.length >= 2 && num_array[0] ==  num_array[num_array.length-1])

@ Test first & last arr1 same arr2
 if(num_array1.length>=2 && num_array2.length>=2)
  {
	  System.out.println(num_array1[0] == num_array2[0] || num_array1[num_array1.length-1] == num_array2[num_array2.length-1]);
  }
  else
  {
   System.out.println("Array lengths less than 2.");
  }
  
@ len 2, 1st ele from arr1, last ele from arr2
- #Arrays.toString(arrName); //to print array in [,,] format
int[] array_new = {array1[0], array2[2]}

@ rotate in left direction
- [20,30,40] -> [30,40,20]
int[] newArr = {oriArr[1], oriArr[2], oriArr[0]};

@ larger val between first & last
- set max = first; then compare if last>first, max = last
- mid val = arr[arr.length/2]
int max_val = array_nums[0];
	if(array_nums[2] >= max_val)
		max_val = array_nums[2];

@ multiply corresponding elements of 2 arrays of int
			for (int i = 0; i < left_array.length; i++) {
				int num1 = left_array[i];
				int num2 = right_array[i];
				result += Integer.toString(num1 * num2) + " "; 
			}

@ contains 10 next to 10 or 20 next to 20, but not both
for(int i = 0; i < nums.length - 1; i++) {
        if(nums[i] == 10 && nums[i+1] == 10)
            found1010 = true;
                        
        if(nums[i] == 20 && nums[i+1] == 20)
            found2020 = true;
 }
 System.out.printf( String.valueOf(found1010 != found2020));	

@ rearrange odd b4 even
while(i < array_nums.length && array_nums[i] % 2 == 0)		//If is even
        i++;							//move to next
              
    for(int j = i + 1; j < array_nums.length; j++) {		//for the element need
        if(array_nums[j] % 2 != 0) {
            int temp = array_nums[i];
            array_nums[i] = array_nums[j];
            array_nums[j] = temp;
            i++;
        }
    }           

@ array size n with 0 to n-1 string values
String[] arr_string = new String[n];
	
    for(int i = 0; i < n; i++)
        arr_string[i] = String.valueOf(i); 

@ check have x, then y later
 for(int i = 0; i < array_nums.length; i++) {
        if(array_nums[i] == x)
            testd = true;
                    
        if(testd && array_nums[i] == y)
		{
         System.out.printf( String.valueOf(true));	
         result = 1		 ;
		}
    }

@ check contains a specified num next to each other or same specified num separated by one ele
for(int i = 0; i < array_nums.length - 1; i++) {
        if(array_nums[i] == x && array_nums[i+1] == x)
            {
         System.out.printf( String.valueOf(true));	
         result = 1 ;
		}
                  
        if(i <= array_nums.length - 3 && array_nums[i] == x && array_nums[i+2] == x)
           {
         System.out.printf( String.valueOf(true));	
         result = 1 ;
		}
    } //result = 0 print false
    
@ check 20 appears 3 time, no 20's next to each other
if(array_nums.length >= 1 && array_nums[0] == 20)		//if appear at first index, count+1
        count++;

    for(int i = 1; i < array_nums.length; i++) {		//for loop start at index 1
        if(array_nums[i - 1] == 20 && array_nums[i] == 20)	//if this and next before is 20, then false
		{
         System.out.printf( String.valueOf(false));	
         result = 1;						//skip the if loop for count = 3
		}                   
        if(array_nums[i] == 20)					//if this is 20, but next before not 20, then count+1
            count++;
    }
    if (result==0)						//only after check no 20 next to 20
 	  {
     	 System.out.printf( String.valueOf(count == 3));	         
	  }	
	  System.out.printf("\n");	
    }

*@ check a specified num appears in every pair of adjacent element
boolean result = true;
for(int i = 0; i < array_nums.length - 1; i++) {
   if(array_nums[i] != x && array_nums[i + 1] != x) //#If this not x, and next not x
   {
         result = false;
   }
}

@ count no. of corresponding element of 2 arr differ <=1
for(int i = 0; i < array_nums1.length; i++) {			
        if(Math.abs(array_nums1[i] - array_nums2[i]) <= 1 && array_nums1[i] != array_nums2[i])	//differ<=1 and not same
            ctr++;
    }

@ to print BOOLEAN value: System.out.printf(String.valueOf(booleanCompare));

@ check contains either 10 or 30
for(int i = 0; i < array_nums.length; i++)
     {
      	if(array_nums[i] == 10 || array_nums[i] == 30)
		{	
  		
		   result =0;
		}
      }
	 if (result==1)
 	   System.out.printf( String.valueOf(false));	         
     else
	   System.out.printf(String.valueOf(true));
  }

@ newArr have ele after last 10 in oriArr
int l = array_nums.length - 1;
int[] new_array;
while(array_nums[l] != 10)				//check from behind, where 10 exist is last index
	l--;
new_array = new int[array_nums.length - 1 - l];	
for(int i = l + 1; i < array_nums.length; i++)		//start copy  after the lastindex
	new_array[i - l - 1] = array_nums[i];		// i - l - 1 = 0

@ newArr have ele before last 10 in oriArr //change all arr.length-1 to 0
int l = 0;
	int[] new_array;
	while(array_nums[l] != 10)
	  l++;
	new_array = new int[l];
	for(int i = 0; i < l; i++)
		new_array[i] = array_nums[i];

@ check a grp of num at start & end of arr same
for(int l = 2; l > 0; l--)
	{
		if(array_nums[0] != array_nums[array_nums.length-1])
			result = 1;					//1 false; 0 true
		else
		{
			start++;
			end++;
		}
	}

@ left shifted [11,14,13,10] -> [14,13,10,11]
if(array_nums.length >1)
    {          
    int first = array_nums[0];				//Store ori first value
              
    for(int i = 1; i < array_nums.length; i++)
        array_nums[i - 1] = array_nums[i];		//move all the value 1 index forward
                        
    array_nums[array_nums.length - 1] = first;		//new last index is ori first value

@ check contains 3 increasing num 
- adjacent next = this + 1
for(int i = 0; i <= array_nums.length - 3; i++) {
        if(array_nums[i] + 1 == array_nums[i+1] && array_nums[i+1] + 1 == array_nums[i+2]) //#
            result =0;	//true
    }

@ Merge 2 sorted array into new sorted array
 int[] arr12 = new int [arr1.length + arr2.length];

        for(int i = 0; i<arr1.length; i++){
            arr12[i] = arr1[i];
        }
        int index = 0;
        for(int j = arr1.length; j<(arr1.length+arr2.length); j++){
            arr12[j] = arr2[index];
            index++;
        }
        Arrays.sort(arr12);

@ get first occ (start index 0) of an element of array: Binary Search
int lower = 0;
        int upper = nums.length - 1;
        int index = -1;
        while (lower <= upper) {
            int mid = (lower + upper) >> 1;
            if (nums[mid] == target) {
                index = mid;
            }
            if (nums[mid] >= target) {
                upper = mid - 1;
            } else {
                lower = mid + 1;
            }
        }

***@ Find a contiguous subarray with largest sum from a given array of integers
public static int max_SubArray(int[] nums) {
        if (nums.length < 1) {
            return 0;
        }
        int max = nums[0];
        int max_Begin = 0;
        int max_End = 0;
        int begin = 0;
        int end = 0;
        int sum = 0;
        while (end < nums.length) {
            sum += nums[end];
            if (sum < 0) {
                sum = 0;
                begin = end + 1;
            } else {
                if (sum > max) {
                    max = sum;
                    max_Begin = begin;
                    max_End = end;
                }
            }
            end++;
        }
        return max;
    }

@ find subarray with smallest sum [ArrayList]

@
- find index of a value in a sorted array
- not found : return index where it would be
public static int searchInsert(int[] nums1, int target) {
        if (nums1 == null || nums1.length == 0) {		//create new array
            return 0;
        }
        int result = 0;
        int index = 0;
        for(int i = 0; i<nums1.length; i++){  //find if exist
            if(nums1[i] == target) {
                index = i;
                result = 1;
            }
        }
        if(result == 0){    //if not exist
            int i = nums1.length-1; //loop from behind
            if(nums1[i]>target){    //if target>element, move left
                while(i>=0){
                    i--;
                    }
            }
             index = i+1;   //+1 as it (decrease 1 after found the correct position) & (-1 for =0 if smaller than all) & (next last if bigger than all)
            }
        return index;
        }

@ Median of sorted array
 public static int getMedian(int[] array) {
        if(array.length % 2 == 0) {
            int mid = array.length / 2;
            return (array[mid] + array[mid - 1]) / 2;
        }
        return array[array.length / 2];
    }

@ Find a num appears only ONCE, all numbers occur twice
public static int getSingleNumber(int[] nums) {
       if(nums == null || nums.length == 0) {
         return -1;
        }
        int result = 0;
        for (int i = 0; i < nums.length; i++) {
            result ^= nums[i];				//# ^=
        }
        return result;
    }
}

@ Find new length of a sorted array where each element appear only once (remove duplicates)
static  int removeDuplicates(int[] nums) {
        if (nums == null) {
            return 0;
        }
        if (nums.length <= 1) {
            return nums.length;
        }
        int current_pos = 0;						//prev
        int moving_pos;							//this
        for (moving_pos = 1; moving_pos < nums.length; moving_pos++) {
            if (nums[current_pos] != nums[moving_pos]) {		//if prev != this 
                nums[current_pos + 1] = nums[moving_pos];		//this element stays at this index 
                current_pos++;						//if prev = this, will skip to next, and the next nonduplicate will take this index	
            }
        }
        return current_pos + 1;
    }

@  find new length of sorted array (duplicate ele appeared at most twice)
int index = 1;					//index 1
for (int i = 2; i < nums.length; i++) {		//start 2
       if (nums[i] != nums[index] || (nums[i] == nums[index] && nums[i] != nums[index - 1])) { //#if 2 != 1 || 2!=1 && 2!=0
           index++;
           nums[index] = nums[i];
     }
 }
        return index + 1;

@ check if a string has all unique(non-duplicate) characters
public static boolean is_Unique_str(String str) {
        char[] chars = str.toCharArray();
        Arrays.sort(chars);
        for (int i = 0; i < chars.length-1; i++) {
            if (chars[i] == chars[i+1]) {
                return false;
            }
        }
        return true;
    }

@
public static boolean anagram_test(String str1, String str2) {
        if (str1 == null || str2 == null) {
            return false;
        } else if (str1.length() != str2.length()) {
            return false;
        } else if (str1.length() == 0 && str2.length() == 0) {
            return false;}
        else{
            int index = str2.length() - 1;
            for (int i = 0; i < str1.length(); i++) {
                if (str1.charAt(i) != str2.charAt(index)) {
                    return false;
                }
                index--;
            }
        }
        return true;
    }
  
@ Remove all occurances of a specified value, Return new length
public static int removeElement(int[] nums, int elem) {
      int length = nums.length; 
      if(length==0) return 0; 
      int i=0; 
      for(int j=0; j<length; j++)
      {
        if(nums[j]!=elem)
        {
          nums[i]=nums[j];
          i++; 
        }
      }
      if(i<length) nums[i]='\0';
      return i; 
    }
 
@ Print 2d array 
true false true		t f t
false true false -->    f t f
		int rows_length = array.length;
		int columns_length = array[0].length;
		
		for (int i = 0; i < rows_length; i++) {
			for (int j = 0; j < columns_length; j++) {
				
				if (array[i][j]) {			//get boolean true or false
					System.out.print(" t ");
				} else {
					System.out.print(" f ");
				}
				
			}
			System.out.println();
		}	

@ changing rows & columns
private static void transpose(int[][] twodm) {
		
		int[][] newtwodm = new int[twodm[0].length][twodm.length];
		
		for (int i = 0; i < twodm.length; i++) {
			for (int j = 0; j < twodm[0].length; j++) {
				newtwodm[j][i] = twodm[i][j];
			}
		}

@ print 2d array
private static void print_array(int[][] twodm) {
		for (int i = 0; i < twodm.length; i++) {
			for (int j = 0; j < twodm[0].length; j++) {
				System.out.print(twodm[i][j] + " ");
			}
			System.out.println();
		}
	
	}

@ return largest int but not larger than the base-2-logarithm of given int	[?QTA 156]
https://www.w3resource.com/java-exercises/basic/java-basic-exercise-156.php
int shift_right_count = 0;
        do {
            n >>= 1;
            shift_right_count++;
        } while (n != 0);
         shift_right_count--;

@ create 2d array (m x m) A[][], A[i][j] false if i & j are prime [?QTA 158]
https://www.w3resource.com/java-exercises/basic/java-basic-exercise-158.php

import java.util.Scanner;
public class Solution {
	public static int prime_cell(int a, int b) {
		if (a == 0 || b == 0) {
			return 1;
		}
		if (a < b) {
			int t = a;
			a = b;
			b = t;
		}
		if (a % b == 0) 
		{
			return b;
		} 
		else 
		{
			return prime_cell(b, a % b);
		}
	}

	public static void main(String[] args) {
		int n = 3;
		boolean[][] A = new boolean[n][n];
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				A[i][j] = prime_cell(i, j) == 1;
				System.out.print(A[i][j] + " ");
			}
			System.out.println();
		}
	}
}

@ find k largest elements in array (array in any order)
Arrays.sort(arr, Collections.reverseOrder());         
       for (int i = 0; i < k; i++) 
          System.out.print(arr[i] + " ");
      }      

@ find k smallest elements
Arrays.sort(arr);
  for (int i = 0; i < k; i++)
   System.out.print(arr[i] + " ");
 }

@ find kth smallest & largest element
//kth smallest
Arrays.sort(arr);       		
System.out.print(arr[k-1] + " ");
//kth largest
Arrays.sort(arr, Collections.reverseOrder());  		
System.out.print(arr[k-1] + " ");

@ Find num greater than average of num [easy]
for(int i = 0; i < nums.length; i++) {      
      sum = sum + nums[i];
    }
      double average = sum / nums.length;
for(int i = 0; i < nums.length; i++) {
      if(nums[i] > average) {
        System.out.println(nums[i]);
      }
}
   
@ -ve num to left, +ve num to right
 Arrays.sort(nums);
--------------------
import java.util.*;
public class Solution {
 public static int[] split_sorting_array(int[] nums) {
  if (nums == null) {
   throw new IllegalArgumentException("Null array......!");
  }
  boolean flag = true;
  while (flag) {
   flag = false;
   for (int j = 0; j < nums.length - 1; j++) {
    if (nums[j] > nums[j + 1]) {
     swap(nums, j, j + 1);
     flag = true;
    }
   }
  }
  return nums;
 }
 private static void swap(int[] nums, int left, int right) {
  int temp = nums[right];
  nums[right] = nums[left];
  nums[left] = temp;
 }
 public static void main(String[] args) {
  int[] nums = {-2,3,4,-1,-3,1,2,-4,0};
  System.out.println("\nOriginal array: " + Arrays.toString(nums));
  int[] result = split_sorting_array(nums);
  System.out.println("\nResult: " + Arrays.toString(result));
 }
}

@ move every 0 to right
int index = 0;
        for(int i = 0; i<nums.length; i++){
            if(nums[i] != 0){
                nums[index] = nums[i];
                index++;
            }
        }

        for(int i = index; i<nums.length; i++){
            nums[i] = 0;
        }
------------------------------------------------
public static int[] move_zero(int[] nums) {
     if (nums == null) {
      throw new IllegalArgumentException("Null array!");
    }
    boolean swap = true;
    while (swap) {
      swap = false;
      for (int i = 0; i < nums.length - 1; i++) {
        if (nums[i] == 0 && nums[i + 1] != 0) {
          swap(nums, i, i + 1);
          swap = true;
        }
      }
    }
	return nums;
  }
  private static void swap(int[] nums, int a, int b) {
    int temp = nums[a];
    nums[a] = nums[b];
    nums[b] = temp;
  }

<Matrix>
***@ Searches a value in m x n matrix
	/* Create a matrix: 
	1 2 3
	4 5 6
	7 8 9
	*/
	int[][] matrix = new int[3][3];
        for (int row = 0; row < 3; row ++)
            for (int col = 0; col < 3; col++)
                matrix[row][col] = (1 + row * 3 + col);
	// Print matrix
        for (int row = 0; row < 3; row ++)
        {
            for (int col = 0; col < 3; col++)
              {
                System.out.print(matrix[row][col]+" ");
                if (col == 2)					//New line
                System.out.println();
              }
        }
<Main> System.out.print(Boolean.toString(searchMatrix(matrix, target)));	
//Search
	public static boolean searchMatrix(int[][] matrix, int target) {
        if (matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        int m = matrix.length;
        int n = matrix[0].length;
        int lower = 0;
        int higher = m * n - 1;					//#higher
        while (lower <= higher) {
            int mid = (lower + higher) >> 1;
            int val = matrix[mid / n][mid % n];			//###		
            if (val == target) {
                return true;
            }
            if (val < target) {
                lower = mid + 1;
            } else {
                higher = mid - 1;
            }
        }
        return false;
    }

@ Find a path from top left to bottom right (minimizes sum of all numbers along its path) [?QTA 133]
- move either down or right at any point in time
https://www.w3resource.com/java-exercises/basic/java-basic-exercise-133.php

public static int minPathSum(int[][] grid) {
	//Exception
        if (grid == null || grid.length == 0 || grid[0] == null || grid[0].length == 0) { 
            return 0;
        }
	
	//Create newArr follow oriArr size
        int m = grid.length;
        int n = grid[0].length;
        int[][] temp = new int[m][n];

	//?
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
	    	   
                   if (i == 0 && j == 0) {
                    temp[i][j] = grid[i][j];
                    continue;
                } 
                // Compute temp
                int from_up = i == 0 ? Integer.MAX_VALUE : temp[i - 1][j];
                int from_left = j == 0 ? Integer.MAX_VALUE : temp[i][j - 1];
                temp[i][j] = Math.min(from_up, from_left) + grid[i][j];               
            }
        }
       return temp[m - 1][n - 1];
    }

@ find Possible Unique Paths from top-left corner to bottom-right corner of a given grid (m x n) //[?QTA 136]
- Move either down or right at any point in time
https://www.w3resource.com/java-exercises/basic/java-basic-exercise-136.php

public class Solution {
    /**
     * @param n, m: positive integer (1 <= n ,m <= 100)
     * @return an integer
     */
    public static int unique_Paths(int m, int n) {
        if (m <= 0 || n <= 0) {
            return 0;
        }
        int[][] grid = new int[m][n];
        for (int i = m - 1; i >= 0; --i) {
            for (int j = n - 1; j >= 0; --j) {
                grid[i][j] = get_Paths(grid, i, j);
            }
        }
        return grid[0][0];
    }
    
    private static int get_Paths(int[][] grid, int i, int j) {
        if (i >= grid.length - 1 || j >= grid[0].length - 1) {
            return 1;
        }
        return grid[i][j + 1] + grid[i + 1][j];
    }
    
  public static void main(String[] args) {
		int m = 3;
		int n = 2;
		System.out.println("Unique paths from top-left corner to bottom-right corner of the said grid: "+unique_Paths(m, n));
	}		
} 

@ Find possible unique paths considering some obstacles, from top-left corner to bottom-right corner of a specified grid (m x n) //[?QTA 137]
You can move either down or right at any point in time and an obstacle and empty space is marked as 1 and 0 respectively in the grid. Sample grid:
int[][] obstacle_Grid ={
{0, 0, 0},
{0, 1, 0},
{0, 0, 0},
};
https://www.w3resource.com/java-exercises/basic/java-basic-exercise-137.php

public class Solution {
    public static int uniquePaths_With_obstacle_Grid(int[][] obstacle_Grid) {
		int m = obstacle_Grid.length;
		if (m <= 0) {
			return 0;
		}
		int n = obstacle_Grid[0].length;
		if (n <= 0) {
			return 0;
		}
		int[][] dp = new int[m + 1][n + 1];
		dp[m][n - 1] = 1;
		for (int i = m - 1; i >= 0; --i) {
			for (int j = n - 1; j >= 0; --j) {
				dp[i][j] = (obstacle_Grid[i][j] == 0) ? dp[i + 1][j] + dp[i][j + 1] : 0;
			}
		}
		return dp[0][0];
	}
    
  public static void main(String[] args) {
		int[][] obstacle_Grid ={
                              {0, 0, 0}, 
                              {0, 1, 0}, 
                              {0, 0, 0}, 
                              };
		System.out.println("Unique paths from top-left corner to bottom-right corner of the said grid (considering some obstacles): "+uniquePaths_With_obstacle_Grid(obstacle_Grid));
	}		
}



<Calculation>
@ hexagonArea
- Math.tan; Math.PI
//Area of a hexagon = (6 * s^2)/(4*tan(π/6))
(6*(s*s))/(4*Math.tan(Math.PI/6)

@ polygonArea
//Area of a polygon = (n*s^2)/(4*tan(π/n))
(ns * (side * side)) / (4.0 * Math.tan((Math.PI / ns))

@ Distance between 2 points on earth surface
- Math.toRadians
convert lat1, lon1, lat2, lon2 to radians
earthRadius = 6371.01; //km
// d = radius * arccos(sin(x1) * sin(x2) + cos(x1) * cos(x2) * cos(y1 - y2))
earthRadius * Math.acos(Math.sin(lat1)*Math.sin(lat2) + Math.cos(lat1)*Math.cos(lat2)*Math.cos(lon1 - lon2)) //d = radius * arccos(sin(x1) * sin(x2) + cos(x1) * cos(x2) * cos(y1 - y2))

@ 
- repeat process until n = 1: while(n != 1)



<Number System>
@ convert DEC to BI
- %2 store in arr, divide 2, loop till = 0, print arr from last ele to first ele
int bin_num[] = new int[100];
quot = dec_num;
		
        while(quot != 0)
        {
            bin_num[i++] = quot%2;
            quot = quot/2;
        }

@ convert BI to DEC
- %10, multiply j add to dN, j*2, bN/10
long binaryNumber, decimalNumber = 0, j = 1, remainder;
while (binaryNumber != 0) 
  {
   remainder = binaryNumber % 10;
   decimalNumber = decimalNumber + remainder * j;
   j = j * 2;
   binaryNumber = binaryNumber / 10;
  }

@ convert BI to HEX
- convert BI to DEC, convert DEC to HEX
int[] hex = new int[1000];
int i = 1, j = 0, rem, dec = 0, bin;
while (bin > 0) {
   rem = bin % 2;
   dec = dec + rem * i;
   i = i * 2;
   bin = bin / 10;
  }
   i = 0;
  while (dec != 0) {
   hex[i] = dec % 16;
   dec = dec / 16;
   i++;
  }

@ convert BI to OCT
convert BI to DEC, convert DEC to OCT
 int binnum, binnum1,rem, decnum=0, quot, i=1, j;
 int octnum[] = new int[100];   //Print from last element to first element (j=i-1; j>0; j--)
 while(binnum > 0)
        {
            rem = binnum % 10;
            decnum = decnum + rem*i;
            //System.out.println(rem);
            i = i*2;
            binnum = binnum/10;
        }   

		i=1;
        quot = decnum;
		
        while(quot > 0)
        {
            octnum[i++] = quot % 8;
            quot = quot / 8;
        }        
        
@ convert DEC to HEX
char hex[]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
while(dec_num>0)
        {
            rem = dec_num%16;
            hexdec_num = hex[rem] + hexdec_num;
            dec_num = dec_num/16;
        }
        
@ convert DEC to OCT
- %8 store in arr, divide 8, loop till = 0, print arr from last ele to first ele 
quot = dec_num;
		
        while(quot != 0)
        {
            oct_num[i++] = quot%8;
            quot = quot/8;
        }

@ convert OCT to DEC
while (octal_num != 0) 
     {
      decimal_num = (long)(decimal_num + (octal_num % 10) * Math.pow(8, i++));
      octal_num = octal_num / 10;
     }

@ convert OCT to BI
- %10, binaryNum += rem [as index * place (*1000 each loop) ]
int[] octal_numvalues = {0, 1, 10, 11, 100, 101, 110, 111}; //#
  long octal_num, tempoctal_num, binary_num, place;
  int rem;
  tempoctal_num = octal_num;
  binary_num = 0;
  place = 1;
  while (tempoctal_num != 0)
  {
   rem = (int)(tempoctal_num % 10);
   binary_num = octal_numvalues[rem] * place + binary_num; //#
   tempoctal_num /= 10;
   place *= 1000;
  }
  
@ convert OCT to HEX
decnum = Integer.parseInt(octal_num, 8);
hex_num = Integer.toHexString(decnum);

@ convert HEX to DEC
 public static int hex_to_decimal(String s)
    {
             String digits = "0123456789ABCDEF";
             s = s.toUpperCase();
             int val = 0;
             for (int i = 0; i < s.length(); i++)
             {
                 char c = s.charAt(i);
                 int d = digits.indexOf(c);
                 val = 16*val + d;
             }
             return val;
    }
  
@ convert HEX to BI
- convert HEX to DEC, convert DEC to BI

@ convert HEX to OCT
- convert HEX to DEC, convert DEC to OCT

@ accept int convert into BI, count no. of bits equal to 0
- convert int to str, convert str to char arr, check if char=0 ctr+1
public static int countBitsTozeroBasedOnString(int n) {
    int ctr = 0;
    String binaryNumber = Integer.toBinaryString(n);
	System.out.print("Binary representation of "+n+" is: "+binaryNumber);
    for (char ch : binaryNumber.toCharArray()) {
      ctr += ch == '0' ? 1 : 0;
    }
    return ctr;
  }	



<System>
@ Check JAVA installed
-# System.getProperty("");
    System.out.println("\nJava Version: "+System.getProperty("java.version"));
    System.out.println("Java Runtime Version: "+System.getProperty("java.runtime.version"));
    System.out.println("Java Home: "+System.getProperty("java.home"));
    System.out.println("Java Vendor: "+System.getProperty("java.vendor"));
    System.out.println("Java Vendor URL: "+System.getProperty("java.vendor.url"));
    System.out.println("Java Class Path: "+System.getProperty("java.class.path")+"\n");

@ 
get current system environment: System.out.println(System.getenv());
get current system properties: System.out.println(System.getProperties());

@ check whether a security manager has already been established for the current application or not
System.out.println(System.getSecurityManager());

@ get value of (specified) environment variable PATH, TEMP, USERNAME
System.out.println(System.getenv("PATH"));
System.out.println(System.getenv("TEMP"));
System.out.println(System.getenv("USERNAME"));

<>
@ fileSize
- # new File(fileName).length() //in bytes
- byte(1), kilobyte (1000), megabytes (1,000,000), gigabyte (1,000,000,000), terabyte (1,000,000,000,000)
new File("abc.txt").length() + " bytes"

@ display system time
System.out.format("\nCurrent Date time: %tc%n\n", System.currentTimeMillis());

@ display current date time
SimpleDateFormat cdt = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss.SSS");
		cdt.setCalendar(Calendar.getInstance(TimeZone.getTimeZone("GMT")));
		
		System.out.println("\nNow: "+cdt.format(System.currentTimeMillis()));

@ Measure how long some code takes to execute in nanoseconds
long startTime = System.nanoTime(); 
/*Block of code of program*/
long estimatedTime = System.nanoTime() - startTime;


@ Input & Display Password
-# cons.readPassword("");
		Console cons;											//create object
		if ((cons = System.console()) != null) {							//not empty
			char[] pass_ward = null;								//create array to store
			try {
				pass_ward = cons.readPassword("Input your Password:");				//Read: cons.readPassword("");
				System.out.println("Your password was: " + new String(pass_ward));		//Print: new String(charArr)
			} finally {
				if (pass_ward != null) {							//if charArr not empty
					java.util.Arrays.fill(pass_ward, ' ');					//fill entire pass_ward array with ' ' according to the size set in try{}
				}
			}
		} else {
			throw new RuntimeException("Can't get password...No console");
		}
	}



<ArrayList>
@ Create ArrayList
ArrayList<Type> ALname = new ArrayList<Type>();

@ Add element
ALname.add();

*@ Find smallest sum of subarray
public static int min_SubArray(ArrayList<Integer> nums) { 
   int[] nums1 = new int[nums.size()];						//create new array
        nums1[0] = nums.get(0);							//arr first ele is AL first ele
        int min = nums1[0];							//min initialize as arr first ele 
        for (int i = 1; i < nums.size(); ++i) {					//loop through arr
            nums1[i] = Math.min(nums.get(i), nums.get(i) + nums1[i - 1]);	//following ele is min(this ele, sum of this ele & previous ele)
            min = Math.min(min, nums1[i]);					//compare min with this ele to set min
        }
        return min;								
 }

@ Return array of longest word
ArrayList<String> aL = new ArrayList<String>();
int longest_length = 0;
for(String str: arr){
	int length = str.length();
	if(length > longest_length){
		longest_length = length;
		aL.clear();
	}
	if(length == longest_length){
		aL.add(str);
	}
}

@ merge all overlapping intervals from a given a collection of intervals
#// Source: https://bit.ly/2PjMfds
import java.util.*;

public class Solution
{   
    public static void main (String[] args) throws java.lang.Exception
    {
        ArrayList<Interval> x = new ArrayList<>();

        x.add(new Interval(1, 3));
        x.add(new Interval(2, 6));
        x.add(new Interval(8, 10));
        x.add(new Interval(15, 18));
        x.add(new Interval(17, 20));

        x = merge(x);

        for(Interval i : x)
        {
            System.out.println(i.getStart() + " " + i.getEnd());
        }
    }

    public static ArrayList<Interval> merge(ArrayList<Interval> intervals) {

        if(intervals.size() == 0 || intervals.size() == 1)
            return intervals;

        Collections.sort(intervals, new IntervalComparator());

        Interval first = intervals.get(0);
        int start = first.getStart();
        int end = first.getEnd();

        ArrayList<Interval> result = new ArrayList<Interval>();

        for (int i = 1; i < intervals.size(); i++) {
            Interval current = intervals.get(i);
            if (current.getStart() <= end) {
                end = Math.max(current.getEnd(), end);
            } else {
                result.add(new Interval(start, end));
                start = current.getStart();
                end = current.getEnd();
            }
        }

        result.add(new Interval(start, end));
        return result;
    }
}

class Interval 
{
    private int start;
    private int end;

    Interval() {
        start = 0;
        end = 0;
    }

    Interval(int s, int e) 
    {
        start = s;
        end = e;
    }

    public int getStart() {
        return start;
    }

    public int getEnd() {
        return end;
    }
}

class IntervalComparator implements Comparator<Interval>
{
    public int compare(Interval i1, Interval i2)
    {
        return i1.getStart() - i2.getStart();
    }
}


>>HOTS<<
<Linked List>
[121] https://www.w3resource.com/java-exercises/basic/java-basic-exercise-121.php
[135] Remove duplicates https://www.w3resource.com/java-exercises/basic/java-basic-exercise-135.php

<Binary Tree>
[125] https://www.w3resource.com/java-exercises/basic/java-basic-exercise-125.php
[126] https://www.w3resource.com/java-exercises/basic/java-basic-exercise-126.php
[127] https://www.w3resource.com/java-exercises/basic/java-basic-exercise-127.php
[130] https://www.w3resource.com/java-exercises/basic/java-basic-exercise-130.php
[150] Test is a subtree of another https://www.w3resource.com/java-exercises/basic/java-basic-exercise-150.php

<Binary Search Tree>
@ Convert sorted array to binary search tree. Maintain minimal height of the tree.
https://www.w3resource.com/java-exercises/basic/java-basic-exercise-146.php

<List> & <Map>

@ get index of firstNum & lastNum of subarray where sumOfNums = 0
1 2 3 -6 5 4 >> {1,2,3,-6} sum = 0
import java.util.*;
public class Solution {
    public static List<Integer> subarraySum(int[] nums) {
        List<Integer> temp = new ArrayList<>();
        if (nums == null || nums.length == 0) {
            return temp;
        }
        int pre_Sum = 0;
        Map<Integer, Integer> map = new HashMap<>();
        map.put(pre_Sum, -1);
        for (int i = 0; i < nums.length; i++) {
            pre_Sum += nums[i];
            if (map.containsKey(pre_Sum)) {
                temp.add(map.get(pre_Sum) + 1);
                temp.add(i);
                return temp;
            }
            map.put(pre_Sum, i);
        }
        return temp;
    }
    
public static void main(String[] args) {
		int [] nums = {1, 2, 3, -6, 5, 4};
		System.out.println("Original Array : "+Arrays.toString(nums));
		System.out.println("Index of the subarray of the said array where the sum of numbers is zero: "+subarraySum(nums));
	}		
}

<List, listNode>
[143] Merge 2 given sorted lists https://www.w3resource.com/java-exercises/basic/java-basic-exercise-143.php
[145] Remove nth element from end https://www.w3resource.com/java-exercises/basic/java-basic-exercise-145.php





