<Challenging>
@ remove ele (X alter size, after removal last ele exist twice)
for(int i = removeIndex; i < my_array.length -1; i++){
        my_array[i] = my_array[i + 1];
      }

@ Insert ele (specific position)
for(int i=my_array.length-1; i > Index_position; i--){
    my_array[i] = my_array[i-1];
   }
   my_array[Index_position] = newValue;

@ Find duplicate
for (int i = 0; i < my_array.length-1; i++)
        {
            for (int j = i+1; j < my_array.length; j++)
            {
                if ((my_array[i] == my_array[j]) && (i != j)) //(my_array[i].equals(my_array[j])) for string
                { //print my_array[j]

@ Remove duplicate
int no_unique_elements = my_array.length;                           //assume all ele unique
 for (int i = 0; i < no_unique_elements; i++) 
        {
            for (int j = i+1; j < no_unique_elements; j++)
            {
              if(my_array[i] == my_array[j])                        //2 eles found equal
                {
                    my_array[j] = my_array[no_unique_elements-1];   //replace duplicate ele with last unique
                    no_unique_elements--; 
                    j--; }}}
int[] array1 = Arrays.copyOf(my_array, no_unique_elements);  //Copying only unique elements to newArr

@ Find common (int)
for (int i = 0; i < array1.length; i++)
        {
            for (int j = 0; j < array2.length; j++)
            {
                if(array1[i] == (array2[j]))
                { //print array1[i]

@ Find common (str)
HashSet<String> set = new HashSet<String>();
 
        for (int i = 0; i < array1.length; i++)
        {
            for (int j = 0; j < array2.length; j++)
            {
                if(array1[i].equals(array2[j]))
                {
                    set.add(array1[i]); }}} //print (set)

@ Find all pairs of eles sum = specified num
for (int i =  0; i < inputArray.length; i++)
  {
  for (int j  = i+1; j < inputArray.length; j++)
  {
  if(inputArray[i]+inputArray[j] == inputNumber)
  { //then print arr[i], arr[j]

@ find missing num in arr (using smallest & largest)
int expected_num_sum = total_num * ((total_num + 1) / 2);       //total num is num of ele
int num_sum = 0;
   for (int i: numbers) {
    num_sum += i;
   }
       System.out.print( expected_num_sum - num_sum);

@ move all zero to right
        for(int j = 0, l = array_nums.length; j < l;) {
            if(array_nums[j] == 0)                      //if is 0, continue increase index
                j++;
            else {
                int temp = array_nums[i];               //if not 0, swap the value with front is 0
                array_nums[i] = array_nums[j];
                array_nums[j] = temp;
                i ++;
                j ++;
            }
        }

@ check contains 2 specified num
public static boolean result(int[] array_nums, int num1, int num2) {
    for (int number : array_nums) {
      boolean r = number != num1 && number != num2;                     //#
      if (r) {                                                          //#
        return false;
        }
     }
        return true;
   }

@ remove duplicate ele & return new length
public static int array_sort(int[] nums) {
         int index = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] != nums[index-1])               //# only if not same with b4 we add, index-1 can be used if arr sorted
                nums[index++] = nums[i];                
        }
	  return index;                                 //count til unique ele
    }




<Random>
@ Sort
Arrays.sort(arrName)

@ sum
for (int i : my_array)
    sum += i;
@ average = sum/numbers.length;

@ contains value
for (int n : arr) {
         if (item == n) {
            return true;
         }
      }

@ find index of ele
int i = 0;
        while (i < len) {
            if (my_array[i] == t) return i;
            else i=i+1;
        }

@ copy by iterating
for(int i=0; i < my_array.length; i++) {
    new_array[i] = my_array[i];
}

@ reverse
for(int i = 0; i < my_array1.length / 2; i++)
  {
    int temp = my_array1[i];
    my_array1[i] = my_array1[my_array1.length - i - 1];   //#
    my_array1[my_array1.length - i - 1] = temp;
  }

@ max min
int len = my_array.length;
        if (len < 1) {
            max = -1;
            min = -1;
        }
        if (len >= 1) {
            max = my_array[0];
            min = my_array[0];
            for (int i = 1; i < len; i++) {
                if (my_array[i] > max) max = my_array[i];
                if (my_array[i] < min) min = my_array[i];
            }
        }

@ find 2nd largest ele
Arrays.sort(arr)
//print (arr[arr.length - 1 -1]);

@ find 2nd smallest ele
Arrays.sort(arr)
// print (arr[1]);

@ add 2 matrices of same size
for ( c = 0 ; c < m ; c++ )
         for ( d = 0 ; d < n ; d++ )
             sum[c][d] = array1[c][d] + array2[c][d]; 

<OutTopic>

@ Convert to ArrayList
 ArrayList<String>  list = new ArrayList<String>(Arrays.asList(oriArrName));

@ Convert from ArrayList
String[]  my_array = new String[list.size()];
  list.toArray(my_array);

@ test equality
boolean  equalOrNot = true;
  
  if(my_array1.length == my_array2.length)
  {
  for (int i  = 0; i < my_array1.length; i++)
  {
  if(my_array1[i] != my_array2[i])
  {
  equalOrNot = false;

@ compute avg value except largest & smallest
float x = ((sum-max-min) / (array_nums.length - 2));

@ check without 0 & -1
for (int number : numbers) {
      if (number == 0 || number == -1) {
        return false;
      }

@ check if sum of all search_num's in arr is exactly fixed_num
public static boolean result(int[] numbers, int search_num, int fixed_sum) {
   int temp_sum = 0;
   for (int number : numbers) {
      if (number == search_num) {
        temp_sum += search_num;
      }

      if (temp_sum > fixed_sum) {
        break;
      }
    }
    return temp_sum == fixed_sum;
  }  
}

@ Find length of longest consecutive elements sequence
Arrays.sort(arr);
        int count = 1;
        for(int i = 0; i< arr.length-1; i++){
            if (arr[i] == arr[i+1]-1){
                count ++;
            }
        }


<Exception>
if (arr == null) return -1;

<SHAPE>
@
- - - -
- - - -
- - - -
- - - -
int [][]a = new int[4][4];    
 for(int i = 0; i < 4; i++)
   {
      for(int j = 0; j < 4; j++)
      {
         System.out.printf("%2d ", a[i][j]);   //print the char
      }
      System.out.println(); //new line after every 4 column
   }

<ArrayList>
@ Find common elements from 3 sorted (in non-decreasing order) arrays
ArrayList<Integer> common = new ArrayList<Integer>();
while (x < array1.length && y < array2.length && z < array3.length){
            if (array1[x] == array2[y] && array2[y] == array3[z]){
                common.add(array1[x]);
                x++;
                y++;
                z++;
            }
            //to still increase the index (while if cond not meet) to avoid infinity loop
            else if (array1[x] < array2[y])
                x++;
            else if (array2[y] < array3[z])
                y++;
            else
                z++;
        }

<HashSet>
@ Find length of longest consecutive elements sequence from a given unsorted array of int
 public static int longest_sequence(int[] nums) {
      final HashSet<Integer> h_set = new HashSet<Integer>();
        for (int i : nums) h_set.add(i);

        int longest_sequence_len = 0;
        for (int i : nums) {
            int length = 1;
            for (int j = i - 1; h_set.contains(j); --j) {
                h_set.remove(j);
                ++length;
            }
            for (int j = i + 1; h_set.contains(j); ++j) {
                h_set.remove(j);
                ++length;
            }
            longest_sequence_len = Math.max(longest_sequence_len, length);
        }
        return longest_sequence_len;
    }
    










